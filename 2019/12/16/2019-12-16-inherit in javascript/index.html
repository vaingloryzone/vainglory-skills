
<!DOCTYPE html>
<html lang="zh-cn" class="loading">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>VainGlory Zone</title>

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="vainglory,"> 
    <meta name="description" content="一个有温度的虚荣攻略站, 免费领取柬埔寨礼包
这个我在B站上专门录制了非常详细的操作步骤
经测试，在3.9版本仍然适用哦。 另外，如果不能连接GOOLGE的，请使用网易UU下载虚荣亚服版的，并使用经纬度进行定位哈。
最后要,"> 
    <meta name="author" content="Vincent Ko"> 
    <link rel="alternative" href="atom.xml" title="VainGlory Zone" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <link rel="stylesheet" href="/css/diaspora.css">
</head>
</html>
<body class="loading">
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">JavaScript中的几种设计模式</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>
    <div class="section">
        <div class="article">
    <div class="main">
        <h1 class="title">JavaScript中的几种设计模式</h1>
        <div class="stuff">
            <span>十二月 16, 2019</span>
            
  <ul class="post-tags-list"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/前端开发/">前端开发</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/设计模式/">设计模式</a></li></ul>


        </div>
        <div class="content markdown">
            <h2 id="单例模式"><a class="markdownIt-Anchor" href="#单例模式"></a> 单例模式</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">var person = &#123;</span><br><span class="line">	name : &quot;Tom&quot;,</span><br><span class="line">	age: 12</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 = &#123;</span><br><span class="line">	name : &quot;toony&quot;,</span><br><span class="line">	age : &quot;11&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是单例模式</p>
<ul>
<li>作用： 实现分组，把描述同一个事物的属性和方法放在了同一个空间中，起到了分组的作用，避免了相同变量名之间的干扰</li>
<li>在单例模式中，我们把对象名叫<strong>命名空间</strong></li>
<li>单例模式是我们项目中常用的模式，因为可以利用它进行模块化开发。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//同样都用change方法，为了避免污染</span><br><span class="line">var sideBar = &#123;</span><br><span class="line">	change : function ()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var headBar = &#123;</span><br><span class="line">	change : function ()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="工厂模式"><a class="markdownIt-Anchor" href="#工厂模式"></a> 工厂模式</h2>
<p>为了实现”低冗余，高聚合“的方式，为了批量生产，于是有了工厂模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function creatPerson(name,age)&#123;</span><br><span class="line">	var obj = &#123;&#125;;</span><br><span class="line">	obj.name = name;</span><br><span class="line">	obj.age = age;</span><br><span class="line">	obj.writeJs = function () &#123;</span><br><span class="line">		console.log(&apos;ha&apos; + obj.name + &apos;can write JS&apos;);</span><br><span class="line">	&#125;</span><br><span class="line">	return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是，不用像单例模式那样，进行多次的重复的写内容了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var person1 = creatPerson(&quot;tom&quot;,15);</span><br><span class="line">var person2 = creatPerson(&quot;tony&quot;,22);</span><br></pre></td></tr></table></figure>
<p><strong>特点</strong>：</p>
<ol>
<li>把实现相同功能的代码放到一个函数中，以后再想实现这个功能，不需要重新编写代码，只要运行代码即可   &gt;&gt;&gt;我们把这个叫<strong>函数的封装</strong>    <mark>低耦合，高内聚</mark></li>
</ol>
<h3 id="面向对象的编程语言"><a class="markdownIt-Anchor" href="#面向对象的编程语言"></a> 面向对象的编程语言</h3>
<ul>
<li>封装   封装已经实现，就是函数</li>
<li>继承   通过原型链实现</li>
<li>多态   当前方法和类的多种姿态，包括 重载和重写</li>
</ul>
<h4 id="多态之重载"><a class="markdownIt-Anchor" href="#多态之重载"></a> 多态之重载</h4>
<p>方法名相同，参数类型、个数不同。<br>
但是，JS中没有重载，因为当重复写的时候，会被覆盖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function sum (num,num)&#123;&#125;</span><br><span class="line">function sum (num) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这是不行的，因此JS是没有重载的(overload)！！<br>
但是可以通过if语句判断，来模拟实现重载(overload)<br>
<strong>但是JS有多态，因为有重写</strong></p>
<h3 id="构造函数模式"><a class="markdownIt-Anchor" href="#构造函数模式"></a> 构造函数模式</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function CreatPerson (name,age) &#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">	this.age = age;</span><br><span class="line">	this.writeJs = function ()&#123;</span><br><span class="line">		console.log(&quot;my name is &quot; + this.name + &quot;I can write JS&quot;); </span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var tom = CreatPerson(&quot;tom&quot;,12);</span><br></pre></td></tr></table></figure>
<p>这就是构造函数设计模式，注意方面里面的this是在调用的时候，才知道指向谁； 而前面的属性上的this，则是在构造函数时，指向实例。 因为构造函数，遇到new 的时候，会自己创建一个this对象，最后再自动返回this对象。</p>
<p>这种，在内建对象中，也有类似的模式，比如创建数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [];</span><br><span class="line">var arr1 = new Array();</span><br></pre></td></tr></table></figure>
<p>不管哪组方式，arr都是 Array的实例。<br>
但是注意： 不同实例的方法虽然名称相同，但是是不同的东西，那是各自实例的私有属性，单独的个体。</p>
<h4 id="这个不是单例模式而是构造函数模式"><a class="markdownIt-Anchor" href="#这个不是单例模式而是构造函数模式"></a> 这个不是单例模式，而是构造函数模式</h4>
<p>有的时候，面试官认为这个是单例模式，实际上，这并不是，这个是构造函数模式，也创造了单独的对象，但是在W3C中是可以查询的！</p>
<ol>
<li>JS中，所有类都是函数数据类型的，它与函数没有很大的区别。只不过在new的时候，会自动创建一个this对象，最后再自动返回。 (注意，实例都是object类型)</li>
<li>构造函数中，this.xxx中的this都是指向实例本身。 在方法中，this需要等待调用才有所指代</li>
<li>p1和p2中都是同一个类的实力，都有相同的方法，但是那是私有属性，是单独个体，不相等。</li>
</ol>
<h4 id="还有一些特点扩展"><a class="markdownIt-Anchor" href="#还有一些特点扩展"></a> 还有一些特点(扩展)</h4>
<ol>
<li>var p1 = new CreatPerson 在构造函数中，如果没有参数，括号可以省略.  但是函数执行是不可以省略的</li>
<li>如果提前return了一个对象，则会返回新的对象；如果返回一个基本数据类型，则没有任何影响</li>
<li>检测一个实例是否是一个类的实力  <code>instanceof</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(p1 instanceof CreatPerson);  //true</span><br><span class="line">console.log(p1 instanceof(CreatPerson)); //true</span><br><span class="line">console.log(p1 instanceof Array) ;  //false</span><br><span class="line">console.log(p1 instanceof Object) ; //true</span><br></pre></td></tr></table></figure>
<p>检测数据类型来说，typeof不能准确检测Array的具体类型(只能返回object)。 可以使用<code>istanceof</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [];</span><br><span class="line">console.log(arr istanceof Array);  //true</span><br><span class="line">//也可以使用Object下的</span><br><span class="line">console.log(Object.prototype.toString(arr)) //返回[object Array]</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>检测某一个实例是否有某个属性  <code>in</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">	name : &quot;tom&quot;,</span><br><span class="line">	age : 12</span><br><span class="line">&#125;</span><br><span class="line">console.log(&quot;age&quot; in obj) //true;</span><br></pre></td></tr></table></figure>
<p>注意in无论是共有(prototype)还是私有的，都会返回。 因此，为了检测私有属性，有hasOwnProperty</p>
<ol start="5">
<li>检测某一个属性是否是私有属性 <code>hasOwnProperty</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(obj.hasOwnProperty(&apos;age&apos;)) //true;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>写一个检测共有属性的方法 <code>hasPubProperty</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function hasPubProperty (obj,property) &#123;</span><br><span class="line">	return property in obj &amp;&amp; !obj.hasOwnProperty(property);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="原型链模式"><a class="markdownIt-Anchor" href="#原型链模式"></a> 原型链模式</h3>
<ol>
<li>数组去重,链式写法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.myUnique = function () &#123;</span><br><span class="line">	var obj = &#123;&#125;;</span><br><span class="line">	for(var i = 0; i &lt; this.length; i++ )&#123;</span><br><span class="line">		var cur = this[i];</span><br><span class="line">		if(obj[cur] == cur)&#123;</span><br><span class="line">			this[i] = this[this.length -1];</span><br><span class="line">			this.length--;</span><br><span class="line">			i--;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		obj[cur] = cur;</span><br><span class="line">	&#125;</span><br><span class="line">	return this;  //实现链式写法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>写一个mySlice方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.mySlice = function (start,end) &#123;</span><br><span class="line">	var arr = [],</span><br><span class="line">		rArr = [];</span><br><span class="line">	start &lt; 0? start += this.length : start;</span><br><span class="line">	end &lt; 0? end += this.length : end;</span><br><span class="line">	end &gt;= this.length? end = this.length : end;</span><br><span class="line">	for(var i = 0; i&lt; this.length - 1 ; i++)&#123;</span><br><span class="line">		if(start &lt;= i)&#123;</span><br><span class="line">			arr[arr.length] = this[i];</span><br><span class="line">		&#125;</span><br><span class="line">		if(end == i-1)&#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return arr;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="原型链批量设置共有属性的小问题"><a class="markdownIt-Anchor" href="#原型链批量设置共有属性的小问题"></a> 原型链批量设置共有属性的小问题</h4>
<p>当有多项属性、方法需要在原型链上配置的时候，可以使用批量设置，但是注意，一定要设置好constuctor</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Myfun.prototype = &#123;</span><br><span class="line">	constructor: Myfun,</span><br><span class="line">	this.show: function () &#123;</span><br><span class="line">		console.log(this.name);</span><br><span class="line">	&#125;,</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://ww1.sinaimg.cn/large/6f9f3683ly1fy8tozcht2j21510m415m.jpg" alt=""><br>
<strong>记住这张图中的内容，这种设置方式相当于新开辟的一个内存地址来保存prototype，如果没有设置contructor，这个时候，constructor 就会指向Object。</strong></p>
<p>另一方面，如果直接内置的类上批量添加，因为会覆盖原有的很多方法，因此浏览器会屏蔽这种设置方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype = &#123;&#125;</span><br><span class="line">//这种方法无效</span><br></pre></td></tr></table></figure>
<h2 id="原型继承"><a class="markdownIt-Anchor" href="#原型继承"></a> 原型继承</h2>
<ol>
<li>最常用的方法；</li>
<li>子类B想要继承父类A中所有的属性和方法（私有+共有)，让B的prototype = A的实例。<code>B.prototype = new A</code></li>
<li>原型继承特点，父类私有和共有的都变成了子类私有的方法和属性。</li>
</ol>
<h2 id="圣杯模式"><a class="markdownIt-Anchor" href="#圣杯模式"></a> 圣杯模式</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var inherit = (function () &#123;</span><br><span class="line">	var function F() &#123;&#125;</span><br><span class="line">	return function (Origin,Target)&#123;</span><br><span class="line">		F.prototype = Origin.prototype;</span><br><span class="line">		Target.prototype = new F；</span><br><span class="line">		Target.prototype.constructor = Target;</span><br><span class="line">		Target.prototype.uber = Origin;</span><br><span class="line">&#125;</span><br><span class="line">&#125; ())</span><br></pre></td></tr></table></figure>
<h2 id="中间类继承"><a class="markdownIt-Anchor" href="#中间类继承"></a> 中间类继承</h2>
<p>这个比较特殊，主要用在一个问题上:</p>
<blockquote>
<p>当遇到argument[]这种类数组时，无法使用数组的方法，很蛋疼。比如想封装一个平均值的方法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function avgFn() &#123;</span><br><span class="line">	var sum;</span><br><span class="line">	Array.prototype.sort.call(arguments,function (a,b) &#123;return a-b&#125;);  //升序排列，扔掉一个最大，一个最小</span><br><span class="line">	Array.prototype.pop().call(arguments);</span><br><span class="line">	Array.prototype.shift().call(arguments);</span><br><span class="line">	for(var i = 0; i &lt; arguments.length; i++)&#123;</span><br><span class="line">		sum += arr[i]</span><br><span class="line">	&#125;</span><br><span class="line">	return sum/arguments.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显得很麻烦，因为要通过调用Array的方法。所以，这里可以直接修改类数组(同样也是对象)的<code>__proto__</code> 属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arguments.__proto__ = Array.prototype;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="true">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        <li title="0" data-url="http://music.163.com/song/media/outer/url?id=536622304.mp3"></li>
                    
                        <li title="1" data-url="http://music.163.com/song/media/outer/url?id=436487129.mp3"></li>
                    
                </ul>
            
        </div>
        
    <div id="gitalk-container" class="comment link" data-ae="false" data-ci="06f0ad91196f39ecb0d6" data-cs="57a534c24e1bc6b28b51f7fa7323389690ad48da" data-r="gittalk" data-o="forrany" data-a="forrany,vaingloryzone" data-d="false">查看评论</div>


    </div>
    
        <div class="side">
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#单例模式"><span class="toc-number">1.</span> <span class="toc-text"> 单例模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工厂模式"><span class="toc-number">2.</span> <span class="toc-text"> 工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#面向对象的编程语言"><span class="toc-number">2.1.</span> <span class="toc-text"> 面向对象的编程语言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#多态之重载"><span class="toc-number">2.1.1.</span> <span class="toc-text"> 多态之重载</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造函数模式"><span class="toc-number">2.2.</span> <span class="toc-text"> 构造函数模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#这个不是单例模式而是构造函数模式"><span class="toc-number">2.2.1.</span> <span class="toc-text"> 这个不是单例模式，而是构造函数模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#还有一些特点扩展"><span class="toc-number">2.2.2.</span> <span class="toc-text"> 还有一些特点(扩展)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原型链模式"><span class="toc-number">2.3.</span> <span class="toc-text"> 原型链模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#原型链批量设置共有属性的小问题"><span class="toc-number">2.3.1.</span> <span class="toc-text"> 原型链批量设置共有属性的小问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#原型继承"><span class="toc-number">3.</span> <span class="toc-text"> 原型继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#圣杯模式"><span class="toc-number">4.</span> <span class="toc-text"> 圣杯模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中间类继承"><span class="toc-number">5.</span> <span class="toc-text"> 中间类继承</span></a></li></ol>
        </div>
    
</div>


    </div>
</div>
</body>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/diaspora.js"></script>
<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<!-- Google Analytics -->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-130886357-1', 'auto');
  ga('send', 'pageview');
</script>
<!-- End Google Analytics -->


</html>